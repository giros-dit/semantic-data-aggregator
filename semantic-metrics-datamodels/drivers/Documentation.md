# Developing a YANG-based Driver Application Using the YANG Tools Java Library

This is a guide for the steps involved in developing YANG-based drivers, which are Java applications that aim to normalize data from a source according to its particular data model structured following the YANG modeling language [1]. These driver applications are implemented based on the YANG Tools library [2]. Driver programming is mainly based on the Java bindings generated by YANG Tools. The Java bindings are the structuring of the data model representation in the form of Java code that are automatically generated from the defined YANG model. Using these bindings, a concrete representation of the YANG data tree can be built in order to normalize data that matches with the relative YANG model.

# Table of Contents
1. [Creating a project with Maven](#creating-a-project-with-maven)
2. [Implementation of the YANG model](#implementation-of-the-yang-model)
3. [Updating the pom.xml file](#updating-the-pomxml-file)
   - [Properties](#properties)
   - [Dependencies](#dependencies)
   - [Plugins](#plugins)
4. [Creating the Java class](#creating-the-java-class)
   - [The driver method](#the-driver-method)
5. [Compiling and executing the project](#compiling-and-executing-the-project)
6. [References](#references)


## Creating a project with Maven

The first step is to create an archetype with Maven. Depending on the type of project you want to create (i.e., a NiFi processor or a Flink streaming application), you will have to choose one maven archetype or another. For the latter case (with Flink), the following steps have been carried out for the generation in interactive mode.

- From the desired directory, run `mvn archetype:generate`
- Then, type `flink` to filter and display only related options.
- Next, choose the specific Flink archetype you want to create. In our case, the option `remote -> org.apache.flink:flink-quickstart-java` has been chosen. 
- Also, the desired Flink version must be chosen (e.g., `1.14.0`).
- After this, you are asked for the name you want to set in the `groupId` and in the `artifactId`, the former referring to what you want to call the work package and the latter the name of the Java project. An example of these parameters for the specific case of the NetFlow driver, could be `tid` and `netflow-driver`, respectively.
- Finally, the `version` and `package` must be chosen. If you want the default version (`1.0-SNAPSHOT`) just press the `Enter` key, otherwise you can specify any other, for example `1.0`. Regarding the package, the default option has been selected so that the project is created directly in the specified directory.


If the process has finished successfully, a directory with the same name set in `artifactId` should have been created containing a `src/` folder and the `pom.xml` file.


## Implementation of the YANG model

Depending on the data provided by the data source to be incorporated into the `SDA`, a YANG model has to be developed. Therefore, before starting with the programming of the Java code of the driver, the model must first be implemented (for this purpose, it has been decided to use version 1.1 of the YANG modeling language). 

Once the YANG model has been developed, it must be included in the corresponding directory. Subsequently, this directory will be taken into account when using the YANG Tools Java library to implement the driver (this will be explained in more detail later). Although it is true that the directory where the corresponding YANG models are stored can be configured in the `pom.xml` file, in our case it has been decided to follow the same pattern for all the drivers. Specifically, the models have been included in different folders depending on the specific data source within the [`yang-models`](../yang-models/) directory created in the root directory of this GitHub repository. For example, the YANG models corresponding to NetFlow have been included in the [`yang-models/netflow`](../yang-models/netflow) directory.

## Updating the pom.xml file
As discussed above, when generating the Maven project a `pom.xml` file is automatically created. However, this will need to be modified in order to compile the project without errors. 

In this file three sections can be distinguished, which are where the project properties, the necessary dependencies and the different plugins are defined. Each of them will be described in detail below.

### Properties 
At the beginning of the `pom.xml` file and specifically in the properties section, you must check that the value of the different tags is correct. It is important to properly specify the Java version being used (`<target.java.version>` tag), which will be the same value to be associated with the maven compiler (`<maven.compiler.source>` and `<maven.compiler.target>` tags). In this part you must also specify the path where the bindings will be generated (these will be used later to implement the Java class code), as well as the path where the yang models and the different resources are located (tags `<salGeneratorPath>`, `<yangFilesPath>` and `<resourcePath>`, respectively). The following is an example specifying the properties, where `<data-source-folder-name>` refers to the specific folder created for the data source under study.
```
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <flink.version>1.14.0</flink.version>
    <target.java.version>11</target.java.version> 
    <scala.binary.version>2.11</scala.binary.version>
    <maven.compiler.source>${target.java.version}</maven.compiler.source>
    <maven.compiler.target>${target.java.version}</maven.compiler.target>
    <log4j.version>2.17.1</log4j.version>
    <salGeneratorPath>target/generated-sources/mdsal-binding</salGeneratorPath>
    <yangFilesPath>../../../yang-models/<data-source-folder-name></yangFilesPath>
    <resourcePath>src/main/resources</resourcePath>
</properties>
```


### Dependencies
In the next section of the file, the different dependencies used are specified. If the `driver` is to be integrated with Apache Flink, it is common to first specify the dependencies that are related to this tool. It should be noted that some of them are created automatically when the project is generated with Maven. However, there are others that do not appear and must be specified. Below is an example of the Flink-related dependencies needed to develop a streaming application integrated with the `driver` in Java that also makes use of Apache Kafka. 

```
<dependencies>
    <!-- Apache Flink dependencies -->
    <!-- These dependencies are provided, because they should not be packaged into the JAR file. -->
    <dependency>
        <groupId>org.apache.flink</groupId>
	<artifactId>flink-java</artifactId>
	<version>${flink.version}</version>
	<scope>provided</scope>
    </dependency>

    <dependency>
        <groupId>org.apache.flink</groupId>
        <artifactId>flink-core</artifactId>
	<version>${flink.version}</version>
	<scope>provided</scope>
    </dependency>
    
    <dependency>
        <groupId>org.apache.flink</groupId>
	<artifactId>flink-streaming-java_${scala.binary.version}</artifactId>
	<version>${flink.version}</version>
	<scope>provided</scope>
    </dependency>
    
    <dependency>
        <groupId>org.apache.flink</groupId>
	<artifactId>flink-clients_${scala.binary.version}</artifactId>
	<version>${flink.version}</version>
	<scope>provided</scope>
    </dependency>
    
    <dependency>
        <groupId>org.apache.flink</groupId>
	<artifactId>flink-test-utils_${scala.binary.version}</artifactId>
	<version>${flink.version}</version>
	<scope>test</scope>
    </dependency> 

    <dependency>
        <groupId>org.apache.flink</groupId>
	<artifactId>flink-runtime_${scala.binary.version}</artifactId>
	<version>1.9.0</version>
	<scope>test</scope>
	<classifier>tests</classifier>
     </dependency>

     <!-- runtime-web dependency is need to start web UI from IDE -->
     <dependency>
         <groupId>org.apache.flink</groupId>
	 <artifactId>flink-runtime-web_${scala.binary.version}</artifactId>
	 <version>${flink.version}</version>
	 <scope>provided</scope>
     </dependency>

     <!-- Add connector dependencies here. They must be in the default scope (compile). -->
     <dependency>
         <groupId>org.apache.flink</groupId>
	 <artifactId>flink-connector-kafka_${scala.binary.version}</artifactId>
	 <version>${flink.version}</version>
	 <scope>compile</scope>
     </dependency>

     <dependency>
         <groupId>org.apache.flink</groupId>
	 <artifactId>flink-connector-files</artifactId>
	 <version>1.15-SNAPSHOT</version>
	 <scope>compile</scope>
     </dependency>
...

```

Subsequently, the dependencies that have to do with the application logging are added.  It is usual to add the following three dependencies.

```
     <!-- Add logging framework, to produce console output when running in the IDE. -->
     <!-- These dependencies are excluded from the application JAR by default. -->
     <dependency>
         <groupId>org.apache.logging.log4j</groupId>
	 <artifactId>log4j-slf4j-impl</artifactId>
	 <version>${log4j.version}</version>
     </dependency>
		
     <dependency>
         <groupId>org.apache.logging.log4j</groupId>
	 <artifactId>log4j-api</artifactId>
	 <version>${log4j.version}</version>
     </dependency>

     <dependency>
         <groupId>org.apache.logging.log4j</groupId>
	 <artifactId>log4j-core</artifactId>
	 <version>${log4j.version}</version>
     </dependency>
...

```
Later, the dependencies that are necessary for the specific Java application to be developed are included. This part is usually edited as the code of the Java class is being developed (since errors related to the dependencies that have not been included will appear). For examples of dependencies within this part, see the `pom.xml` files of other drivers already implemented (e.g., the one in the [`sources/netflow`](sources/netflow/) directory).

Finally, in this section all dependencies related to the YANG TOOLS library should be added. It should be noted here that it is very important to avoid compilation errors that all dependencies whose `groupId` is `org.opendaylight.mdsal` must have the same version associated to them, as well as those with `groupId` equal to `org.opendaylight.yangtools`. All YANG TOOLS-related dependencies that are required in this type of `drivers` are specified below.

```
     <!-- Yangtools dependencies -->
     <dependency>
         <groupId>org.opendaylight.mdsal</groupId>
	 <artifactId>mdsal-binding-runtime-api</artifactId>
	 <version>7.0.9</version>
     </dependency>

     <dependency>
         <groupId>org.opendaylight.mdsal</groupId>
	 <artifactId>mdsal-binding-runtime-spi</artifactId>
	 <version>7.0.9</version>
     </dependency>

     <dependency>
         <groupId>org.opendaylight.mdsal</groupId>
	 <artifactId>mdsal-binding-generator-impl</artifactId>
	 <version>7.0.9</version>
     </dependency>

     <dependency>
         <groupId>org.opendaylight.mdsal</groupId>
	 <artifactId>mdsal-binding-dom-codec-api</artifactId>
	 <version>7.0.9</version>
	 <scope>compile</scope>
     </dependency>
		
     <dependency>
         <groupId>org.opendaylight.mdsal</groupId>
	 <artifactId>mdsal-binding-dom-codec-spi</artifactId>
	 <version>7.0.9</version>
	 <scope>compile</scope>
     </dependency>

     <dependency>
         <groupId>org.opendaylight.mdsal</groupId>
	 <artifactId>mdsal-binding-dom-codec</artifactId>
	 <version>7.0.9</version>
	 <scope>compile</scope>
     </dependency>
		
     <dependency>
         <groupId>org.opendaylight.mdsal</groupId>
	 <artifactId>mdsal-binding-spec-util</artifactId>
	 <version>7.0.9</version>
	 <scope>compile</scope>
     </dependency>

     <dependency>
         <groupId>org.opendaylight.mdsal</groupId>
	 <artifactId>mdsal-dom-api</artifactId>
	 <version>7.0.9</version>
	 <scope>compile</scope>
     </dependency>
		
     <dependency>
         <groupId>org.opendaylight.mdsal</groupId>
	 <artifactId>yang-binding</artifactId>
	 <version>7.0.9</version>
     </dependency>
     
     <dependency>
         <groupId>org.opendaylight.yangtools</groupId>
	 <artifactId>yang-data-api</artifactId>
	 <version>6.0.7</version>
     </dependency>
     
     <dependency>
         <groupId>org.opendaylight.yangtools</groupId>
	 <artifactId>yang-data-codec-xml</artifactId>
	 <version>6.0.7</version>
     </dependency>
     
     <dependency>
         <groupId>org.opendaylight.yangtools</groupId>
	 <artifactId>yang-data-codec-gson</artifactId>
	 <version>6.0.7</version>
     </dependency>
     
     <dependency>
         <groupId>org.opendaylight.yangtools</groupId>
	 <artifactId>yang-model-api</artifactId>
	 <version>6.0.7</version>
	 <type>jar</type>
     </dependency> 
     
     <dependency>
	 <groupId>org.opendaylight.yangtools</groupId>
	 <artifactId>yang-parser-impl</artifactId>
	 <version>6.0.7</version>
	 <type>jar</type>
     </dependency>
     
     <dependency>
         <groupId>org.opendaylight.yangtools</groupId>
	 <artifactId>yang-parser-reactor</artifactId>
	 <version>6.0.7</version>
	 </dependency> 
	 
     <dependency>
	 <groupId>org.opendaylight.yangtools</groupId>
	 <artifactId>yang-parser-api</artifactId>
	 <version>6.0.7</version>
     </dependency>
   
     <dependency>
         <groupId>org.opendaylight.yangtools</groupId>
	 <artifactId>yang-parser-spi</artifactId>
	 <version>6.0.7</version>
     </dependency>

</dependencies>

```

### Plugins

The last part of the `pom.xml` defines the different plugins. It is worth mentioning here that all plugins in turn must be integrated into a tag called `<build>`. First of all, the plugin related to the maven compiler is usually defined. Here it is important to point out an appropriate version, which depends on the version of Java you are using. A possible example of such a plugin is shown below.

```
<build>
    <plugins>
        <!-- Java Compiler -->
	<plugin>
	    <groupId>org.apache.maven.plugins</groupId>
	    <artifactId>maven-compiler-plugin</artifactId>
	    <version>3.8.0</version>
	    <configuration>
	        <source>${target.java.version}</source>
		<target>${target.java.version}</target>
	    </configuration>
	</plugin>

...
```

Then, as can be seen in other `pom.xml`, maven-related plugins are included, such as `maven-resources-plugin`, `maven-surefire-plugin`, `maven-jar-plugin`, `maven-install-plugin`, among others.

After this, you have to add plugins that allow the generation of Java bindings from a YANG model. Therefore, here it is very important to correctly specify the corresponding paths. An example of these plugins is shown below.

```
        <!-- Yangtools, generate yang -->
	<plugin>
	    <groupId>org.opendaylight.yangtools</groupId>
	    <artifactId>yang-maven-plugin</artifactId>
	    <version>6.0.7</version>
	    <configuration>
	        <source>1.11</source>
		<target>1.11</target>
	    </configuration>
	    <dependencies>
	        <dependency>
		    <groupId>org.opendaylight.mdsal</groupId>
		    <artifactId>maven-sal-api-gen-plugin</artifactId>
		    <version>7.0.9</version>
		    <type>jar</type>
		</dependency>
	    </dependencies>
	    <executions>
	        <execution>
		    <id>binding</id>
		    <goals>
		        <goal>generate-sources</goal>
		    </goals>
		    <configuration>
		        <yangFilesRootDir>${yangFilesPath}</yangFilesRootDir>
			<codeGenerators>
			    <generator>
			        <codeGeneratorClass>org.opendaylight.mdsal.binding.maven.api.gen.plugin.CodeGeneratorImpl</codeGeneratorClass>
				<outputBaseDir>${salGeneratorPath}</outputBaseDir>
				<resourceBaseDir>${resourcePath}</resourceBaseDir>
			    </generator>
			</codeGenerators>
			<inspectDependencies>true</inspectDependencies>
		    </configuration>
		 </execution>
	     </executions>
	</plugin>
	
	<plugin>
	    <artifactId>maven-clean-plugin</artifactId>
	    <version>3.1.0</version>
	    <configuration>
	        <filesets>
		    <fileset>
		        <directory>${salGeneratorPath}</directory>
			<includes>
			    <include>**</include>
			</includes>
		    </fileset>
		 </filesets>
	    </configuration>
	 </plugin>
	 
	 <!-- add generated yang classes to build -->
	 <plugin>
	    <groupId>org.codehaus.mojo</groupId>
	    <artifactId>build-helper-maven-plugin</artifactId>
	    <version>3.1.0</version>
	    <executions>
	        <execution>
		    <id>add-yang-sources</id>
		    <phase>generate-sources</phase>
		    <goals>
		        <goal>add-source</goal>
		    </goals>
		    <configuration>
		        <sources>
		            <source>${salGeneratorPath}</source>
		        </sources>
		    </configuration>
		 </execution>
	     </executions>
	 </plugin>
...
```

Finally, if you are developing the `driver` integrated with Flink, it is important to add the plugin that allows you to generate a `jar` containing all the necessary dependencies. In addition, it is required to specify the name of the main class of the project within the `<mainClass>` tag. This name must be specified as `<package-name>.<java-class-name>`. The following is an example of this plugin.

```
         <plugin>
             <groupId>org.apache.maven.plugins</groupId>
	     <artifactId>maven-shade-plugin</artifactId>
	     <version>3.1.1</version>
	     <executions>
	         <execution>
	             <phase>package</phase>
		     <goals>
		         <goal>shade</goal>
		     </goals>
		     <configuration>
		         <artifactSet>
		             <excludes>
		                 <exclude>org.apache.flink:flink-shaded-force-shading</exclude>
				 <exclude>com.google.code.findbugs:jsr305</exclude>
				 <exclude>org.slf4j:*</exclude>
				 <exclude>org.apache.logging.log4j:*</exclude>
				 </excludes>
			 </artifactSet>
			 <filters>
			     <filter>
			         <!-- Do not copy the signatures in the META-INF folder. Otherwise, this might cause SecurityExceptions when using the JAR. -->
				<artifact>*:*</artifact>
				<excludes>
				    <exclude>META-INF/*.SF</exclude>
				    <exclude>META-INF/*.DSA</exclude>
				    <exclude>META-INF/*.RSA</exclude>
				</excludes>
			     </filter>
			 </filters>
			 <transformers>
			     <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
			         <mainClass>tid.NetflowDriver</mainClass>
			     </transformer>
			 </transformers>
		     </configuration>
		 </execution>
	     </executions>
         </plugin>
         
     </plugins>
</build>

```
	
## Creating the Java class
 
In this section of the documentation, we will try to explain in a generalized way the steps to follow when generating the code of Java class that will implement the `driver`. Inside the `src/main/java/<package-name>` directory, you will find the `.java` file corresponding to the main class of project. The name of this file must match the name specified inside the `pom.xml` in the `mainClass` tag (this has already been discussed above). 
 
Within this class, different methods can be distinguished. The only one that is generated automatically is the `main` method. If you want to integrate with Flink, in this method you will have to specify what is necessary to implement the desired Flink streaming application (you can see an example in the application developed for the NetFlow data source, which is located in the [`sources/netflow/src/main/java/tid/`](sources/netflow/src/main/java/tid/) directory). In addition, from there the call to the method called `driver` must be made, which will be in charge of serializing the input data to the JSON-IETF format according to the developed YANG model. The implementation of this method is detailed below.

### The driver method

As already mentioned, this method must be generated and its main function is to structure data according to a particular YANG model and serialize it to JSON-IETF format. It is important to note that the method arguments will depend on the specific driver application being developed. To achieve the goal of the `driver` method, it will make use of the YANG Tools library since the data format will depend on a YANG model. It is worth mentioning here that some variables and a method called `doConvert` that will be used later in the implementation of the `driver` method must be included beforehand. The concrete code for these variables and the method is shown below (for specific details on the libraries to be imported, it is recommended to look at the code of other implemented drivers). The meaning and functionality of the variables and method is as follows:
- `schemaContext`: the first thing you need to do if you want to work with YANG models is to instantiate a `EffectiveModelContext` object. This object type describes one or more parsed YANG modules for representing a static view of the addressed YANG model.
- `CODEC_SUPPLIER`:  an instantiation of a `JSONCodecFactorySupplier` object working as a JSON codec factory for serializing YANG-modeled data into JSON encoding format.
- `doConvert`: this method allows performing the serialization of the data that is normalized according with the YANG model (i.e., the normalization process previously performed by the main `driver` method)  into the JSON encoding format. To do this, the method receives an instantiation of a `NormalizedNode` object that represents the node instances in the data model tree which are normalized according to the YANG model, and also an instantiation of the `SchemaPath` object that represents the paths to each node normalized according to the YANG model described by the `schemaContext`. Then, the `doConvert` method uses the `JSONCodecFactory` that allows serializing the YANG-modeled data into JSON format.

```
private static final EffectiveModelContext schemaContext = BindingRuntimeHelpers.createEffectiveModel(BindingReflections.loadModuleInfos());
private static final String JSON_IO_ERROR = "I/O problem in JSON codec";
private static final Logger LOG = LogManager.getLogger(<java-class-name>.class);
private static final JSONCodecFactorySupplier CODEC_SUPPLIER = JSONCodecFactorySupplier.RFC7951
private static final JsonParser PARSER = new JsonParser();

/**
 * Performs the actual data conversion.
 * @param schemaPath - schema path for data
 * @param data - Normalized Node
 * @return data converted as a JsonObject
*/
private static JsonObject doConvert(SchemaPath schemaPath, NormalizedNode<?, ?> data) {
    try (StringWriter writer = new StringWriter();
        JsonWriter jsonWriter = JsonWriterFactory.createJsonWriter(writer)) {
            final JSONCodecFactory codecFactory = CODEC_SUPPLIER.getShared(schemaContext);
            final NormalizedNodeStreamWriter jsonStream = (data instanceof MapEntryNode)
                    ? JSONNormalizedNodeStreamWriter.createNestedWriter(codecFactory, schemaPath, null, jsonWriter)
                    : JSONNormalizedNodeStreamWriter.createExclusiveWriter(codecFactory, schemaPath, null, jsonWriter);
            try (NormalizedNodeWriter nodeWriter = NormalizedNodeWriter.forStreamWriter(jsonStream)) {
                nodeWriter.write(data);
                nodeWriter.flush();
            }
            return PARSER.parse(writer.toString()).getAsJsonObject();
        } catch (IOException e) {
            LOG.error(JSON_IO_ERROR, e);
            return null;
        }
}

```
Focusing on the so-called `driver` method, the first thing to do is to initialise the builders of the generated YANG bindings. To do this, it is recommended to execute the `mvn generate-sources` command (which allows to generate the bindings in the indicated path), as this will facilitate programming since Java will activate the auto-complete function of the code. In addition, the following rules must be taken into account in this part:
 - For each container declared in the YANG model, its builder must be initialised. An example in the case of the Netflow YANG model (which can be found in the directory [`yang-models/netflow`](../yang-models/netflow)) could be:
 
   ```
   NetflowBuilder netflow_builder = new NetflowBuilder();
   ExportPacketBuilder exporter_builder = new ExportPacketBuilder();
   ```
 
 - For each list declared in the YANG model, in addition to initialising its builder, an `ArrayList` object of the corresponding type must also be created. Again, an example focusing on the NetFlow case could be the following: 
   ```
   FlowDataRecordBuilder flow_builder = new FlowDataRecordBuilder();
   ArrayList<FlowDataRecord> flow_list = new ArrayList<FlowDataRecord>();
   ```

After initializing the builders, the input data is collected (depending on the particular collector used) and its values are associated with the corresponding node modelled in the YANG model. In addition, in this part it should be clear to which parent node each child node of the model belongs. To do this, you must first store the input data in a variable (e.g., called `data`) and then associate each specific data to the corresponding setter method, following the structure below: 

```
<builder-name>.<setter-method-name>(<typed-input-data>);
```

It should be noted here that `<typed-input-data>` refers to input data with a type already determined according to how this data is defined in the YANG model. Below are several examples particularized to the NetFlow case in order to give a better understanding of this part of the implementation. It is important to note that the NetFlow driver implementation is particularized to the GoFlow2 collector [3]. Of course, the following lines of code will change depending on the particular driver being developed. Again, for more details it is recommended to go to the full code.

```
//EXPORT PACKET INFORMATION
//Header data
exporter_builder.setSequenceNumber(Counter32.getDefaultInstance(data.get("SequenceNum").getAsString()));
exporter_builder.setSourceId(Uint32.valueOf(data.get("SourceId").getAsString()));
exporter_builder.setUnixSeconds(Timestamp.getDefaultInstance(data.get("UnixSeconds").getAsString()));
...

//Flow data record fields
flow_builder.setDirection(DirectionType.forValue(data.get("FlowDirection").getAsInt()));
flow_builder.setFirstSwitched(Timestamp.getDefaultInstance(data.get("TimeFlowStart").getAsString()));
flow_builder.setLastSwitched(Timestamp.getDefaultInstance(data.get("TimeFlowEnd").getAsString()));
...
```

Once all fields have been mapped to their corresponding builders, each child container must be associated to the parent container. The following code should be used to do this:
```
<child-container-name> <desired-object-name> = <child-builder-name>.build();
<parent-builder-name>.<child-setter-method-name>(<desired-object-name>);
```

Again, examples are shown below for the NetFlow case. 
```
Ipv4Builder ipv4_builder = new Ipv4Builder();
//Associate with its parent container
Ipv4 ipv4_container = ipv4_builder.build();
flow_builder.setIpv4(ipv4_container);
```

In the case of lists, once all the fields have been mapped, they must be added to each element of the list (as with any other `<ArrayList>` in Java). To do this, the following structure must be used.

```
<list-name> <desired-object-name> = <list-builder-name>.build();
<arrayList-name>.add(<desired-object-name>);
```

In the specific case of NetFlow, the correct code would be as follows:
``` 
//Build a list with all flow fields 
FlowDataRecord flow_record = flow_builder.build();
flow_list.add(flow_record);
```

After correctly associating all child containers up to the parent container of the model, the following code must be used in all drivers that make use of YANG TOOLS.
```
final <superparent-container-name> <desired-object-name> = <superparent-builder-name>.build();
InstanceIdentifier<<superparent-container-name>> iid = InstanceIdentifier.create(<superparent-container-name>.class);
JsonObject gson_obj = new JsonObject();

try {
    BindingNormalizedNodeSerializer codec = new BindingCodecContext(BindingRuntimeHelpers.createRuntimeContext(<superparent-container-name>.class);
    Entry<YangInstanceIdentifier, NormalizedNode<?, ?>> normalized = codec.toNormalizedNode(iid, <desired-object-name>);
    gson_obj = doConvert(schemaContext.getPath(), normalized.getValue());
        
} catch (Exception ex) {
    //TODO: handle exception
    ex.printStackTrace();
    StringWriter errors = new StringWriter();
    ex.printStackTrace(new PrintWriter(errors));
    LOG.error(errors.toString());
}

```

Finally, if you want the normalized data to be printed in a more readable JSON format, you can use the following code.

```
Gson gson_format = new GsonBuilder().setPrettyPrinting().create();
return gson_format.toJson(gson_obj);
```


## Compiling and executing the project
 
Once the `pom.xml` file has been updated and the Java code of the application has been implemented, the last step is the compilation of the project and its subsequent execution. The steps to be followed for a successful compilation of the project are as follows (of course, within the project directory where the `pom.xml` is located).
 1. The Java bindings are generated in the indicated path, for which the following command is used: `mvn generate-sources`.
 2. The Java project is compiled, tested and packaged. In addition, we decide to remove all `.class` files and Java `resources`, which is recommended if you are using a GitHub repository. To accomplish all this, you need to run the following command: `mvn clean install`
 
If the process has finished successfully, the corresponding `jar` file should have been generated in the `/target` directory, which is located in the root directory of the project. In addition, the driver application will be ready to be run from the desired IDE. 

 
 ## References
 
- [1] Ed. M. Bjorklund, “The YANG 1.1 Data Modeling Language” Aug. 2016, doi: 10.17487/RFC7950
- [2] OpenDaylight Project, “YANG Tools Developer Guide” 2016, https://docs.opendaylight.org/en/stable-phosphorus/developer-guides/yang-tools.html (accessed Mar. 24, 2022)
- [3] GitHub repository, “netsampler/goflow2”, https://github.com/netsampler/goflow2 (accessed Mar. 24, 2022).
