from datetime import datetime
from fastapi import FastAPI, status, Request
from fastapi.responses import JSONResponse
from prometheus_api_client import PrometheusConnect
from typing import Optional

import random


def metricKVTemplate(entity_id, sample):
    metric = {
        "id": entity_id,
        "type": "PrometheusMetric",
        "sample": sample,
        "@context": [
            "https://pastebin.com/raw/ueLM6utf"
        ]
    }
    return metric


def metricTemplate(entity_id, sample, timestamp):
    metric = {
        "id": entity_id,
        "type": "PrometheusMetric",
        "sample": {
            "type": "Property",
            "value": sample,
            "observedAt": timestamp
        },
        "@context": [
            "https://pastebin.com/raw/PCe63jxb"
        ]
    }
    return metric


def formatMetrics(metric_data):
    entity_list = []
    for data in metric_data:
        dt = datetime.utcfromtimestamp(data['value'][0]).isoformat()
        # Autogenerated for demo. Once GET /entities/{entityId} is supported
        # take the Id from the request
        entity_id = "urn:ngsi-ld:PrometheusMetric:" + str(
                        random.randint(1, 999))
        metric = metricTemplate(entity_id, data['value'][1], dt)
        entity_list.append(metric)
    return entity_list


# Prometheus Config
prom = PrometheusConnect(url="http://prometheus:9090", disable_ssl=True)

# FastAPI specific code
tags_metadata = [
    {
        "name": "Context Information",
        "description": "NGSI-LD Entities",
    }
]

app = FastAPI(
    title="NGSI-LD API",
    version="1.0.0",
    openapi_tags=tags_metadata)


@app.get("/ngsi-ld/v1/entities/",
         summary="Query entities",
         description="Retrieve a set of entities which matches \
                      a specific query from an NGSI-LD system",
         tags=["Context Information"],
         status_code=status.HTTP_200_OK)
async def queryEntities(type: str,
                        attrs: Optional[str] = None,
                        q: Optional[str] = None,
                        options: Optional[str] = None):
    # TODO: To be retrieved from broker by getting entityId
    metric_name = "prometheus_http_requests_total"
    # TODO: Same thing for labels
    labels = {}
    metric_data = prom.get_current_metric_value(
        metric_name=metric_name,
        labels=labels)
    entity_list = formatMetrics(metric_data)
    headers = {"Content-Type": "application/ld+json"}
    return JSONResponse(content=entity_list, headers=headers)


# API for consumer
@app.post("/hello",
          status_code=status.HTTP_200_OK)
async def consumerHello(request: Request):
    print(await request.json())
