# -*- coding: utf-8 -*-
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_label_openmetrics__metric_families_metric_family_metrics_metric_labels_label(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openmetrics - based on the path /metric-families/metric-family/metrics/metric/labels/label. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A name-value pair. These are used in multiple places:
identifying timeseries, value of INFO metrics,
and exemplars in Histograms
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__value',)

  _yang_name = 'label'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['metric-families', 'metric-family', 'metrics', 'metric', 'labels', 'label']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /metric_families/metric_family/metrics/metric/labels/label/name (string)

    YANG Description: Key of the label
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /metric_families/metric_family/metrics/metric/labels/label/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Key of the label
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /metric_families/metric_family/metrics/metric/labels/label/value (string)

    YANG Description: Value of the label's key
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /metric_families/metric_family/metrics/metric/labels/label/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value of the label's key
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)

  name = __builtin__.property(_get_name)
  value = __builtin__.property(_get_value)


  _pyangbind_elements = OrderedDict([('name', name), ('value', value), ])


class yc_labels_openmetrics__metric_families_metric_family_metrics_metric_labels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openmetrics - based on the path /metric-families/metric-family/metrics/metric/labels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of Labels
associated with a Metric
  """
  __slots__ = ('_path_helper', '_extmethods', '__label',)

  _yang_name = 'labels'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__label = YANGDynClass(base=YANGListType("name",yc_label_openmetrics__metric_families_metric_family_metrics_metric_labels_label, yang_name="label", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['metric-families', 'metric-family', 'metrics', 'metric', 'labels']

  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /metric_families/metric_family/metrics/metric/labels/label (list)

    YANG Description: A name-value pair. These are used in multiple places:
identifying timeseries, value of INFO metrics,
and exemplars in Histograms
    """
    return self.__label
      
  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /metric_families/metric_family/metrics/metric/labels/label (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: A name-value pair. These are used in multiple places:
identifying timeseries, value of INFO metrics,
and exemplars in Histograms
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_label_openmetrics__metric_families_metric_family_metrics_metric_labels_label, yang_name="label", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_label_openmetrics__metric_families_metric_family_metrics_metric_labels_label, yang_name="label", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)""",
        })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=YANGListType("name",yc_label_openmetrics__metric_families_metric_family_metrics_metric_labels_label, yang_name="label", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)

  label = __builtin__.property(_get_label)


  _pyangbind_elements = OrderedDict([('label', label), ])


class yc_metric_point_openmetrics__metric_families_metric_family_metrics_metric_metric_points_metric_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openmetrics - based on the path /metric-families/metric-family/metrics/metric/metric-points/metric-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of MetricPoints in a Metric. If more than one MetricPoint
is exposed for a Metric, then its MetricPoints MUST have
monotonically increasing timestamps.
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__timestamp',)

  _yang_name = 'metric-point'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="value", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='decimal64', is_config=False)
    self.__timestamp = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="timestamp", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='int64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['metric-families', 'metric-family', 'metrics', 'metric', 'metric-points', 'metric-point']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points/metric_point/value (decimal64)

    YANG Description: Required. The value of the metric's sample
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points/metric_point/value (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Required. The value of the metric's sample
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="value", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="value", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='decimal64', is_config=False)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="value", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='decimal64', is_config=False)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points/metric_point/timestamp (int64)

    YANG Description: Optional. The measurement timestamp of the metric's sample
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points/metric_point/timestamp (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.

    YANG Description: Optional. The measurement timestamp of the metric's sample
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="timestamp", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="timestamp", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='int64', is_config=False)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="timestamp", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='int64', is_config=False)

  value = __builtin__.property(_get_value)
  timestamp = __builtin__.property(_get_timestamp)

  __choices__ = {'metric-points-choice': {'metric-point-list': ['value', 'timestamp']}}
  _pyangbind_elements = OrderedDict([('value', value), ('timestamp', timestamp), ])


class yc_metric_points_openmetrics__metric_families_metric_family_metrics_metric_metric_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openmetrics - based on the path /metric-families/metric-family/metrics/metric/metric-points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__timestamp','__metric_point',)

  _yang_name = 'metric-points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="value", parent=self, choice=('metric-points-choice', 'metric-point-single'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='decimal64', is_config=False)
    self.__timestamp = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="timestamp", parent=self, choice=('metric-points-choice', 'metric-point-single'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='int64', is_config=False)
    self.__metric_point = YANGDynClass(base=YANGListType("timestamp",yc_metric_point_openmetrics__metric_families_metric_family_metrics_metric_metric_points_metric_point, yang_name="metric-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='timestamp', extensions=None, choice=False), is_container='list', yang_name="metric-point", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['metric-families', 'metric-family', 'metrics', 'metric', 'metric-points']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points/value (decimal64)

    YANG Description: Required. The value of the metric's sample
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points/value (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Required. The value of the metric's sample
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="value", parent=self, choice=('metric-points-choice', 'metric-point-single'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="value", parent=self, choice=('metric-points-choice', 'metric-point-single'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='decimal64', is_config=False)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="value", parent=self, choice=('metric-points-choice', 'metric-point-single'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='decimal64', is_config=False)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points/timestamp (int64)

    YANG Description: Optional. The measurement timestamp of the metric's sample
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points/timestamp (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.

    YANG Description: Optional. The measurement timestamp of the metric's sample
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="timestamp", parent=self, choice=('metric-points-choice', 'metric-point-single'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="timestamp", parent=self, choice=('metric-points-choice', 'metric-point-single'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='int64', is_config=False)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="timestamp", parent=self, choice=('metric-points-choice', 'metric-point-single'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='int64', is_config=False)


  def _get_metric_point(self):
    """
    Getter method for metric_point, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points/metric_point (list)

    YANG Description: A list of MetricPoints in a Metric. If more than one MetricPoint
is exposed for a Metric, then its MetricPoints MUST have
monotonically increasing timestamps.
    """
    return self.__metric_point
      
  def _set_metric_point(self, v, load=False):
    """
    Setter method for metric_point, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points/metric_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_point() directly.

    YANG Description: A list of MetricPoints in a Metric. If more than one MetricPoint
is exposed for a Metric, then its MetricPoints MUST have
monotonically increasing timestamps.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("timestamp",yc_metric_point_openmetrics__metric_families_metric_family_metrics_metric_metric_points_metric_point, yang_name="metric-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='timestamp', extensions=None, choice=False), is_container='list', yang_name="metric-point", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("timestamp",yc_metric_point_openmetrics__metric_families_metric_family_metrics_metric_metric_points_metric_point, yang_name="metric-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='timestamp', extensions=None, choice=False), is_container='list', yang_name="metric-point", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)""",
        })

    self.__metric_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_point(self):
    self.__metric_point = YANGDynClass(base=YANGListType("timestamp",yc_metric_point_openmetrics__metric_families_metric_family_metrics_metric_metric_points_metric_point, yang_name="metric-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='timestamp', extensions=None, choice=False), is_container='list', yang_name="metric-point", parent=self, choice=('metric-points-choice', 'metric-point-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)

  value = __builtin__.property(_get_value)
  timestamp = __builtin__.property(_get_timestamp)
  metric_point = __builtin__.property(_get_metric_point)

  __choices__ = {'metric-points-choice': {'metric-point-single': ['value', 'timestamp'], 'metric-point-list': ['metric_point']}}
  _pyangbind_elements = OrderedDict([('value', value), ('timestamp', timestamp), ('metric_point', metric_point), ])


class yc_metric_openmetrics__metric_families_metric_family_metrics_metric(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openmetrics - based on the path /metric-families/metric-family/metrics/metric. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Metrics are defined by a unique LabelSet within a MetricFamily.
Metrics MUST contain a list of one or more MetricPoints.
Metrics with the same name for a given MetricFamily
SHOULD have the same set of label names in their LabelSet.

MetricPoints SHOULD NOT have explicit timestamps.

If more than one MetricPoint is exposed for a Metric,
then its MetricPoints MUST have monotonically increasing timestamps
  """
  __slots__ = ('_path_helper', '_extmethods', '__label_set_id','__name','__labels','__metric_points',)

  _yang_name = 'metric'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__label_set_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="label-set-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    self.__labels = YANGDynClass(base=yc_labels_openmetrics__metric_families_metric_family_metrics_metric_labels, is_container='container', yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)
    self.__metric_points = YANGDynClass(base=yc_metric_points_openmetrics__metric_families_metric_family_metrics_metric_metric_points, is_container='container', yang_name="metric-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['metric-families', 'metric-family', 'metrics', 'metric']

  def _get_label_set_id(self):
    """
    Getter method for label_set_id, mapped from YANG variable /metric_families/metric_family/metrics/metric/label_set_id (string)

    YANG Description: LabelSet ID that uniquely identifies a Metric within a MetricFamily.
Identifies generated from the calculated hash of the LabelSet dictionary.
Prometheus internally generates hashes in order to identify label sets.
    """
    return self.__label_set_id
      
  def _set_label_set_id(self, v, load=False):
    """
    Setter method for label_set_id, mapped from YANG variable /metric_families/metric_family/metrics/metric/label_set_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label_set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label_set_id() directly.

    YANG Description: LabelSet ID that uniquely identifies a Metric within a MetricFamily.
Identifies generated from the calculated hash of the LabelSet dictionary.
Prometheus internally generates hashes in order to identify label sets.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="label-set-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label_set_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="label-set-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)""",
        })

    self.__label_set_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label_set_id(self):
    self.__label_set_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="label-set-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /metric_families/metric_family/metrics/metric/name (string)

    YANG Description: Name of the Metric. Combination of the MetricFamily's name plus
one of the available suffixes - if any - given the type of the Metric.

Suffixes for the respective types are:
   Counter: '_total', '_created'
   Summary: '_count', '_sum', '_created', '' (empty)
   Histogram: '_count', '_sum', '_bucket', '_created'
   GaugeHistogram: '_gcount', '_gsum', '_bucket'
   Info: '_info'
   Gauge: '' (empty)
   StateSet: '' (empty)
   Unknown: '' (empty)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /metric_families/metric_family/metrics/metric/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the Metric. Combination of the MetricFamily's name plus
one of the available suffixes - if any - given the type of the Metric.

Suffixes for the respective types are:
   Counter: '_total', '_created'
   Summary: '_count', '_sum', '_created', '' (empty)
   Histogram: '_count', '_sum', '_bucket', '_created'
   GaugeHistogram: '_gcount', '_gsum', '_bucket'
   Info: '_info'
   Gauge: '' (empty)
   StateSet: '' (empty)
   Unknown: '' (empty)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)


  def _get_labels(self):
    """
    Getter method for labels, mapped from YANG variable /metric_families/metric_family/metrics/metric/labels (container)

    YANG Description: Enclosing container for the list of Labels
associated with a Metric
    """
    return self.__labels
      
  def _set_labels(self, v, load=False):
    """
    Setter method for labels, mapped from YANG variable /metric_families/metric_family/metrics/metric/labels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_labels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_labels() directly.

    YANG Description: Enclosing container for the list of Labels
associated with a Metric
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_labels_openmetrics__metric_families_metric_family_metrics_metric_labels, is_container='container', yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """labels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_labels_openmetrics__metric_families_metric_family_metrics_metric_labels, is_container='container', yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)""",
        })

    self.__labels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_labels(self):
    self.__labels = YANGDynClass(base=yc_labels_openmetrics__metric_families_metric_family_metrics_metric_labels, is_container='container', yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)


  def _get_metric_points(self):
    """
    Getter method for metric_points, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points (container)
    """
    return self.__metric_points
      
  def _set_metric_points(self, v, load=False):
    """
    Setter method for metric_points, mapped from YANG variable /metric_families/metric_family/metrics/metric/metric_points (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_points() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_metric_points_openmetrics__metric_families_metric_family_metrics_metric_metric_points, is_container='container', yang_name="metric-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_points must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_metric_points_openmetrics__metric_families_metric_family_metrics_metric_metric_points, is_container='container', yang_name="metric-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)""",
        })

    self.__metric_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_points(self):
    self.__metric_points = YANGDynClass(base=yc_metric_points_openmetrics__metric_families_metric_family_metrics_metric_metric_points, is_container='container', yang_name="metric-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)

  label_set_id = __builtin__.property(_get_label_set_id)
  name = __builtin__.property(_get_name)
  labels = __builtin__.property(_get_labels)
  metric_points = __builtin__.property(_get_metric_points)


  _pyangbind_elements = OrderedDict([('label_set_id', label_set_id), ('name', name), ('labels', labels), ('metric_points', metric_points), ])


class yc_metrics_openmetrics__metric_families_metric_family_metrics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openmetrics - based on the path /metric-families/metric-family/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of Metrics
associated with a MetricFamily
  """
  __slots__ = ('_path_helper', '_extmethods', '__metric',)

  _yang_name = 'metrics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__metric = YANGDynClass(base=YANGListType("label_set_id",yc_metric_openmetrics__metric_families_metric_family_metrics_metric, yang_name="metric", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='label-set-id', extensions=None), is_container='list', yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['metric-families', 'metric-family', 'metrics']

  def _get_metric(self):
    """
    Getter method for metric, mapped from YANG variable /metric_families/metric_family/metrics/metric (list)

    YANG Description: Metrics are defined by a unique LabelSet within a MetricFamily.
Metrics MUST contain a list of one or more MetricPoints.
Metrics with the same name for a given MetricFamily
SHOULD have the same set of label names in their LabelSet.

MetricPoints SHOULD NOT have explicit timestamps.

If more than one MetricPoint is exposed for a Metric,
then its MetricPoints MUST have monotonically increasing timestamps
    """
    return self.__metric
      
  def _set_metric(self, v, load=False):
    """
    Setter method for metric, mapped from YANG variable /metric_families/metric_family/metrics/metric (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric() directly.

    YANG Description: Metrics are defined by a unique LabelSet within a MetricFamily.
Metrics MUST contain a list of one or more MetricPoints.
Metrics with the same name for a given MetricFamily
SHOULD have the same set of label names in their LabelSet.

MetricPoints SHOULD NOT have explicit timestamps.

If more than one MetricPoint is exposed for a Metric,
then its MetricPoints MUST have monotonically increasing timestamps
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("label_set_id",yc_metric_openmetrics__metric_families_metric_family_metrics_metric, yang_name="metric", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='label-set-id', extensions=None), is_container='list', yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("label_set_id",yc_metric_openmetrics__metric_families_metric_family_metrics_metric, yang_name="metric", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='label-set-id', extensions=None), is_container='list', yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)""",
        })

    self.__metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric(self):
    self.__metric = YANGDynClass(base=YANGListType("label_set_id",yc_metric_openmetrics__metric_families_metric_family_metrics_metric, yang_name="metric", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='label-set-id', extensions=None), is_container='list', yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)

  metric = __builtin__.property(_get_metric)


  _pyangbind_elements = OrderedDict([('metric', metric), ])


class yc_metric_family_openmetrics__metric_families_metric_family(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openmetrics - based on the path /metric-families/metric-family. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A MetricFamily MAY have zero or more Metrics.
A MetricFamily MUST have a name, HELP, TYPE, and UNIT metadata.
Every Metric within a MetricFamily MUST have a unique LabelSet.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__metric_type','__unit','__help','__metrics',)

  _yang_name = 'metric-family'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    self.__metric_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknown': {}, 'gauge': {}, 'counter': {}, 'state_set': {}, 'info': {}, 'histogram': {}, 'gauge_histogram': {}, 'summary': {}},), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='metric-type', is_config=False)
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    self.__help = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="help", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    self.__metrics = YANGDynClass(base=yc_metrics_openmetrics__metric_families_metric_family_metrics, is_container='container', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['metric-families', 'metric-family']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /metric_families/metric_family/name (string)

    YANG Description: MetricFamily names are a string and MUST be unique within a MetricSet.
Names SHOULD be in snake_case.
Metric names MUST follow the restrictions in the ABNF section.

Colons in MetricFamily names are RESERVED to signal that
the MetricFamily is the result of a calculation or aggregation
of a general purpose monitoring system.

MetricFamily names beginning with underscores are RESERVED
and MUST NOT be used unless specified by this standard.

The name of a MetricFamily MUST NOT result in a potential clash
for sample metric names as per the ABNF with another MetricFamily
in the Text Format within a MetricSet. An example would be
a gauge called 'foo_created' as a counter called 'foo'
could create a 'foo_created' in the text format.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /metric_families/metric_family/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: MetricFamily names are a string and MUST be unique within a MetricSet.
Names SHOULD be in snake_case.
Metric names MUST follow the restrictions in the ABNF section.

Colons in MetricFamily names are RESERVED to signal that
the MetricFamily is the result of a calculation or aggregation
of a general purpose monitoring system.

MetricFamily names beginning with underscores are RESERVED
and MUST NOT be used unless specified by this standard.

The name of a MetricFamily MUST NOT result in a potential clash
for sample metric names as per the ABNF with another MetricFamily
in the Text Format within a MetricSet. An example would be
a gauge called 'foo_created' as a counter called 'foo'
could create a 'foo_created' in the text format.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)


  def _get_metric_type(self):
    """
    Getter method for metric_type, mapped from YANG variable /metric_families/metric_family/metric_type (metric-type)

    YANG Description: Type specifies the MetricFamily type
    """
    return self.__metric_type
      
  def _set_metric_type(self, v, load=False):
    """
    Setter method for metric_type, mapped from YANG variable /metric_families/metric_family/metric_type (metric-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_type() directly.

    YANG Description: Type specifies the MetricFamily type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknown': {}, 'gauge': {}, 'counter': {}, 'state_set': {}, 'info': {}, 'histogram': {}, 'gauge_histogram': {}, 'summary': {}},), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='metric-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_type must be of a type compatible with metric-type""",
          'defined-type': "openmetrics:metric-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknown': {}, 'gauge': {}, 'counter': {}, 'state_set': {}, 'info': {}, 'histogram': {}, 'gauge_histogram': {}, 'summary': {}},), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='metric-type', is_config=False)""",
        })

    self.__metric_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_type(self):
    self.__metric_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknown': {}, 'gauge': {}, 'counter': {}, 'state_set': {}, 'info': {}, 'histogram': {}, 'gauge_histogram': {}, 'summary': {}},), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='metric-type', is_config=False)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /metric_families/metric_family/unit (string)

    YANG Description: Unit specifies MetricFamily units. If non-empty,
it MUST be a suffix of the MetricFamily name
separated by an underscore. Be aware that further generation
rules might make it an infix in the text format.
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /metric_families/metric_family/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.

    YANG Description: Unit specifies MetricFamily units. If non-empty,
it MUST be a suffix of the MetricFamily name
separated by an underscore. Be aware that further generation
rules might make it an infix in the text format.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)


  def _get_help(self):
    """
    Getter method for help, mapped from YANG variable /metric_families/metric_family/help (string)

    YANG Description: Help is a string and SHOULD be non-empty. It is used to give
a brief description of the MetricFamily for human consumption
and SHOULD be short enough to be used as a tooltip.
    """
    return self.__help
      
  def _set_help(self, v, load=False):
    """
    Setter method for help, mapped from YANG variable /metric_families/metric_family/help (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_help is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_help() directly.

    YANG Description: Help is a string and SHOULD be non-empty. It is used to give
a brief description of the MetricFamily for human consumption
and SHOULD be short enough to be used as a tooltip.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="help", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """help must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="help", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)""",
        })

    self.__help = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_help(self):
    self.__help = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="help", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='string', is_config=False)


  def _get_metrics(self):
    """
    Getter method for metrics, mapped from YANG variable /metric_families/metric_family/metrics (container)

    YANG Description: Enclosing container for the list of Metrics
associated with a MetricFamily
    """
    return self.__metrics
      
  def _set_metrics(self, v, load=False):
    """
    Setter method for metrics, mapped from YANG variable /metric_families/metric_family/metrics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: Enclosing container for the list of Metrics
associated with a MetricFamily
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_metrics_openmetrics__metric_families_metric_family_metrics, is_container='container', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metrics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_metrics_openmetrics__metric_families_metric_family_metrics, is_container='container', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)""",
        })

    self.__metrics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metrics(self):
    self.__metrics = YANGDynClass(base=yc_metrics_openmetrics__metric_families_metric_family_metrics, is_container='container', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  metric_type = __builtin__.property(_get_metric_type)
  unit = __builtin__.property(_get_unit)
  help = __builtin__.property(_get_help)
  metrics = __builtin__.property(_get_metrics)


  _pyangbind_elements = OrderedDict([('name', name), ('metric_type', metric_type), ('unit', unit), ('help', help), ('metrics', metrics), ])


class yc_metric_families_openmetrics__metric_families(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openmetrics - based on the path /metric-families. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A MetricSet is the top level object exposed by OpenMetrics.
It MUST consist of MetricFamilies and MAY be empty.

Each MetricFamily name MUST be unique. The same label name and value
SHOULD NOT appear on every Metric within a MetricSet.

There is no specific ordering of MetricFamilies required within a MetricSet.
An exposer MAY make an exposition easier to read for humans,
for example sort alphabetically if the performance tradeoff makes sense.
  """
  __slots__ = ('_path_helper', '_extmethods', '__metric_family',)

  _yang_name = 'metric-families'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__metric_family = YANGDynClass(base=YANGListType("name",yc_metric_family_openmetrics__metric_families_metric_family, yang_name="metric-family", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metric-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['metric-families']

  def _get_metric_family(self):
    """
    Getter method for metric_family, mapped from YANG variable /metric_families/metric_family (list)

    YANG Description: A MetricFamily MAY have zero or more Metrics.
A MetricFamily MUST have a name, HELP, TYPE, and UNIT metadata.
Every Metric within a MetricFamily MUST have a unique LabelSet.
    """
    return self.__metric_family
      
  def _set_metric_family(self, v, load=False):
    """
    Setter method for metric_family, mapped from YANG variable /metric_families/metric_family (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_family() directly.

    YANG Description: A MetricFamily MAY have zero or more Metrics.
A MetricFamily MUST have a name, HELP, TYPE, and UNIT metadata.
Every Metric within a MetricFamily MUST have a unique LabelSet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_metric_family_openmetrics__metric_families_metric_family, yang_name="metric-family", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metric-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_family must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_metric_family_openmetrics__metric_families_metric_family, yang_name="metric-family", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metric-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)""",
        })

    self.__metric_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_family(self):
    self.__metric_family = YANGDynClass(base=YANGListType("name",yc_metric_family_openmetrics__metric_families_metric_family, yang_name="metric-family", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metric-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='list', is_config=False)

  metric_family = __builtin__.property(_get_metric_family)


  _pyangbind_elements = OrderedDict([('metric_family', metric_family), ])


class openmetrics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openmetrics - based on the path /openmetrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: YANG module to represent metrics.
This module has been inspired by OpenMetrics specification.
  """
  __slots__ = ('_path_helper', '_extmethods', '__metric_families',)

  _yang_name = 'openmetrics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__metric_families = YANGDynClass(base=yc_metric_families_openmetrics__metric_families, is_container='container', yang_name="metric-families", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_metric_families(self):
    """
    Getter method for metric_families, mapped from YANG variable /metric_families (container)

    YANG Description: A MetricSet is the top level object exposed by OpenMetrics.
It MUST consist of MetricFamilies and MAY be empty.

Each MetricFamily name MUST be unique. The same label name and value
SHOULD NOT appear on every Metric within a MetricSet.

There is no specific ordering of MetricFamilies required within a MetricSet.
An exposer MAY make an exposition easier to read for humans,
for example sort alphabetically if the performance tradeoff makes sense.
    """
    return self.__metric_families
      
  def _set_metric_families(self, v, load=False):
    """
    Setter method for metric_families, mapped from YANG variable /metric_families (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_families is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_families() directly.

    YANG Description: A MetricSet is the top level object exposed by OpenMetrics.
It MUST consist of MetricFamilies and MAY be empty.

Each MetricFamily name MUST be unique. The same label name and value
SHOULD NOT appear on every Metric within a MetricSet.

There is no specific ordering of MetricFamilies required within a MetricSet.
An exposer MAY make an exposition easier to read for humans,
for example sort alphabetically if the performance tradeoff makes sense.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_metric_families_openmetrics__metric_families, is_container='container', yang_name="metric-families", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_families must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_metric_families_openmetrics__metric_families, is_container='container', yang_name="metric-families", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=True)""",
        })

    self.__metric_families = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_families(self):
    self.__metric_families = YANGDynClass(base=yc_metric_families_openmetrics__metric_families, is_container='container', yang_name="metric-families", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/open-metrics', defining_module='openmetrics', yang_type='container', is_config=True)

  metric_families = __builtin__.property(_get_metric_families, _set_metric_families)


  _pyangbind_elements = OrderedDict([('metric_families', metric_families), ])


