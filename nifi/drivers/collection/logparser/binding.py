# -*- coding: utf-8 -*-
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_so_log_logparser__so_log(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module logparser - based on the path /so-log. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the record
of a given log.
  """
  __slots__ = ('_path_helper', '_extmethods', '__current_time','__nsID','__nsdID','__total_instantiation_time','__operation_ID_for_instantiation_op_datetime_difference','__hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference','__retrieving_descriptor_from_catalogue_DBs_start_datetime_difference','__ROE_parsing_NSDs_start_datetime_difference','__ROE_retrieve_RL_resources_start_datetime_difference','__PA_calculation_start_datetime_difference','__creating_networks_at_OSM_wrapper_start_datetime_difference','__creating_VNFs_at_OSM_wrapper_start_datetime_difference','__OSM_wrapper_updating_DBs_start_datetime_difference','__ROE_extract_VLs_start_datetime_difference','__ROE_created_VLs_start_datetime_difference','__ROE_updating_DBs_start_datetime_difference','__create_monitoring_jobs_start_datetime_difference','__create_threshold_based_alerts_start_datetime_difference','__create_AIML_alerts_start_datetime_difference','__wrapper_time_start_datetime_difference','__SOA_time','__ROE_time',)

  _yang_name = 'so-log'
  _yang_namespace = 'http://data-aggregator.com/ns/so-log-parser'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    self._extmethods = False
    self.__current_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="current_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='date-and-time', is_config=False)
    self.__nsID = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='string', is_config=False)
    self.__nsdID = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsdID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='string', is_config=False)
    self.__total_instantiation_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="total_instantiation_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__operation_ID_for_instantiation_op_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="operation_ID_for_instantiation_op_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__retrieving_descriptor_from_catalogue_DBs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="retrieving_descriptor_from_catalogue_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__ROE_parsing_NSDs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_parsing_NSDs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__ROE_retrieve_RL_resources_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_retrieve_RL_resources_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__PA_calculation_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="PA_calculation_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__creating_networks_at_OSM_wrapper_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="creating_networks_at_OSM_wrapper_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__creating_VNFs_at_OSM_wrapper_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="creating_VNFs_at_OSM_wrapper_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__OSM_wrapper_updating_DBs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="OSM_wrapper_updating_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__ROE_extract_VLs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_extract_VLs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__ROE_created_VLs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_created_VLs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__ROE_updating_DBs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_updating_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__create_monitoring_jobs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_monitoring_jobs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__create_threshold_based_alerts_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_threshold_based_alerts_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__create_AIML_alerts_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_AIML_alerts_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__wrapper_time_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="wrapper_time_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__SOA_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="SOA_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    self.__ROE_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['so-log']

  def _get_current_time(self):
    """
    Getter method for current_time, mapped from YANG variable /so_log/current_time (date-and-time)

    YANG Description: Time in which value has been captured.
ISO 8601 format with millisecond accuracy.
    """
    return self.__current_time
      
  def _set_current_time(self, v, load=False):
    """
    Setter method for current_time, mapped from YANG variable /so_log/current_time (date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_time() directly.

    YANG Description: Time in which value has been captured.
ISO 8601 format with millisecond accuracy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="current_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_time must be of a type compatible with date-and-time""",
          'defined-type': "logparser:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="current_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='date-and-time', is_config=False)""",
        })

    self.__current_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_time(self):
    self.__current_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="current_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='date-and-time', is_config=False)


  def _get_nsID(self):
    """
    Getter method for nsID, mapped from YANG variable /so_log/nsID (string)

    YANG Description: Network service identifier.
    """
    return self.__nsID
      
  def _set_nsID(self, v, load=False):
    """
    Setter method for nsID, mapped from YANG variable /so_log/nsID (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsID() directly.

    YANG Description: Network service identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nsID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsID must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='string', is_config=False)""",
        })

    self.__nsID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsID(self):
    self.__nsID = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='string', is_config=False)


  def _get_nsdID(self):
    """
    Getter method for nsdID, mapped from YANG variable /so_log/nsdID (string)

    YANG Description: Network service descriptor identifier.
    """
    return self.__nsdID
      
  def _set_nsdID(self, v, load=False):
    """
    Setter method for nsdID, mapped from YANG variable /so_log/nsdID (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsdID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsdID() directly.

    YANG Description: Network service descriptor identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nsdID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsdID must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsdID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='string', is_config=False)""",
        })

    self.__nsdID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsdID(self):
    self.__nsdID = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsdID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='string', is_config=False)


  def _get_total_instantiation_time(self):
    """
    Getter method for total_instantiation_time, mapped from YANG variable /so_log/total_instantiation_time (int64)

    YANG Description: Network service total instantiation time.
    """
    return self.__total_instantiation_time
      
  def _set_total_instantiation_time(self, v, load=False):
    """
    Setter method for total_instantiation_time, mapped from YANG variable /so_log/total_instantiation_time (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_instantiation_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_instantiation_time() directly.

    YANG Description: Network service total instantiation time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="total_instantiation_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_instantiation_time must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="total_instantiation_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__total_instantiation_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_instantiation_time(self):
    self.__total_instantiation_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="total_instantiation_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_operation_ID_for_instantiation_op_datetime_difference(self):
    """
    Getter method for operation_ID_for_instantiation_op_datetime_difference, mapped from YANG variable /so_log/operation_ID_for_instantiation_op_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__operation_ID_for_instantiation_op_datetime_difference
      
  def _set_operation_ID_for_instantiation_op_datetime_difference(self, v, load=False):
    """
    Setter method for operation_ID_for_instantiation_op_datetime_difference, mapped from YANG variable /so_log/operation_ID_for_instantiation_op_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operation_ID_for_instantiation_op_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operation_ID_for_instantiation_op_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="operation_ID_for_instantiation_op_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operation_ID_for_instantiation_op_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="operation_ID_for_instantiation_op_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__operation_ID_for_instantiation_op_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operation_ID_for_instantiation_op_datetime_difference(self):
    self.__operation_ID_for_instantiation_op_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="operation_ID_for_instantiation_op_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference(self):
    """
    Getter method for hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference, mapped from YANG variable /so_log/hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference
      
  def _set_hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference(self, v, load=False):
    """
    Setter method for hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference, mapped from YANG variable /so_log/hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference(self):
    self.__hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_retrieving_descriptor_from_catalogue_DBs_start_datetime_difference(self):
    """
    Getter method for retrieving_descriptor_from_catalogue_DBs_start_datetime_difference, mapped from YANG variable /so_log/retrieving_descriptor_from_catalogue_DBs_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__retrieving_descriptor_from_catalogue_DBs_start_datetime_difference
      
  def _set_retrieving_descriptor_from_catalogue_DBs_start_datetime_difference(self, v, load=False):
    """
    Setter method for retrieving_descriptor_from_catalogue_DBs_start_datetime_difference, mapped from YANG variable /so_log/retrieving_descriptor_from_catalogue_DBs_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retrieving_descriptor_from_catalogue_DBs_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retrieving_descriptor_from_catalogue_DBs_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="retrieving_descriptor_from_catalogue_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retrieving_descriptor_from_catalogue_DBs_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="retrieving_descriptor_from_catalogue_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__retrieving_descriptor_from_catalogue_DBs_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retrieving_descriptor_from_catalogue_DBs_start_datetime_difference(self):
    self.__retrieving_descriptor_from_catalogue_DBs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="retrieving_descriptor_from_catalogue_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_ROE_parsing_NSDs_start_datetime_difference(self):
    """
    Getter method for ROE_parsing_NSDs_start_datetime_difference, mapped from YANG variable /so_log/ROE_parsing_NSDs_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__ROE_parsing_NSDs_start_datetime_difference
      
  def _set_ROE_parsing_NSDs_start_datetime_difference(self, v, load=False):
    """
    Setter method for ROE_parsing_NSDs_start_datetime_difference, mapped from YANG variable /so_log/ROE_parsing_NSDs_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ROE_parsing_NSDs_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ROE_parsing_NSDs_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_parsing_NSDs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ROE_parsing_NSDs_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_parsing_NSDs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__ROE_parsing_NSDs_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ROE_parsing_NSDs_start_datetime_difference(self):
    self.__ROE_parsing_NSDs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_parsing_NSDs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_ROE_retrieve_RL_resources_start_datetime_difference(self):
    """
    Getter method for ROE_retrieve_RL_resources_start_datetime_difference, mapped from YANG variable /so_log/ROE_retrieve_RL_resources_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__ROE_retrieve_RL_resources_start_datetime_difference
      
  def _set_ROE_retrieve_RL_resources_start_datetime_difference(self, v, load=False):
    """
    Setter method for ROE_retrieve_RL_resources_start_datetime_difference, mapped from YANG variable /so_log/ROE_retrieve_RL_resources_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ROE_retrieve_RL_resources_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ROE_retrieve_RL_resources_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_retrieve_RL_resources_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ROE_retrieve_RL_resources_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_retrieve_RL_resources_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__ROE_retrieve_RL_resources_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ROE_retrieve_RL_resources_start_datetime_difference(self):
    self.__ROE_retrieve_RL_resources_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_retrieve_RL_resources_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_PA_calculation_start_datetime_difference(self):
    """
    Getter method for PA_calculation_start_datetime_difference, mapped from YANG variable /so_log/PA_calculation_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__PA_calculation_start_datetime_difference
      
  def _set_PA_calculation_start_datetime_difference(self, v, load=False):
    """
    Setter method for PA_calculation_start_datetime_difference, mapped from YANG variable /so_log/PA_calculation_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_PA_calculation_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_PA_calculation_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="PA_calculation_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """PA_calculation_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="PA_calculation_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__PA_calculation_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_PA_calculation_start_datetime_difference(self):
    self.__PA_calculation_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="PA_calculation_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_creating_networks_at_OSM_wrapper_start_datetime_difference(self):
    """
    Getter method for creating_networks_at_OSM_wrapper_start_datetime_difference, mapped from YANG variable /so_log/creating_networks_at_OSM_wrapper_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__creating_networks_at_OSM_wrapper_start_datetime_difference
      
  def _set_creating_networks_at_OSM_wrapper_start_datetime_difference(self, v, load=False):
    """
    Setter method for creating_networks_at_OSM_wrapper_start_datetime_difference, mapped from YANG variable /so_log/creating_networks_at_OSM_wrapper_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_creating_networks_at_OSM_wrapper_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_creating_networks_at_OSM_wrapper_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="creating_networks_at_OSM_wrapper_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """creating_networks_at_OSM_wrapper_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="creating_networks_at_OSM_wrapper_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__creating_networks_at_OSM_wrapper_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_creating_networks_at_OSM_wrapper_start_datetime_difference(self):
    self.__creating_networks_at_OSM_wrapper_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="creating_networks_at_OSM_wrapper_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_creating_VNFs_at_OSM_wrapper_start_datetime_difference(self):
    """
    Getter method for creating_VNFs_at_OSM_wrapper_start_datetime_difference, mapped from YANG variable /so_log/creating_VNFs_at_OSM_wrapper_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__creating_VNFs_at_OSM_wrapper_start_datetime_difference
      
  def _set_creating_VNFs_at_OSM_wrapper_start_datetime_difference(self, v, load=False):
    """
    Setter method for creating_VNFs_at_OSM_wrapper_start_datetime_difference, mapped from YANG variable /so_log/creating_VNFs_at_OSM_wrapper_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_creating_VNFs_at_OSM_wrapper_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_creating_VNFs_at_OSM_wrapper_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="creating_VNFs_at_OSM_wrapper_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """creating_VNFs_at_OSM_wrapper_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="creating_VNFs_at_OSM_wrapper_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__creating_VNFs_at_OSM_wrapper_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_creating_VNFs_at_OSM_wrapper_start_datetime_difference(self):
    self.__creating_VNFs_at_OSM_wrapper_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="creating_VNFs_at_OSM_wrapper_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_OSM_wrapper_updating_DBs_start_datetime_difference(self):
    """
    Getter method for OSM_wrapper_updating_DBs_start_datetime_difference, mapped from YANG variable /so_log/OSM_wrapper_updating_DBs_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__OSM_wrapper_updating_DBs_start_datetime_difference
      
  def _set_OSM_wrapper_updating_DBs_start_datetime_difference(self, v, load=False):
    """
    Setter method for OSM_wrapper_updating_DBs_start_datetime_difference, mapped from YANG variable /so_log/OSM_wrapper_updating_DBs_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_OSM_wrapper_updating_DBs_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_OSM_wrapper_updating_DBs_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="OSM_wrapper_updating_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """OSM_wrapper_updating_DBs_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="OSM_wrapper_updating_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__OSM_wrapper_updating_DBs_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_OSM_wrapper_updating_DBs_start_datetime_difference(self):
    self.__OSM_wrapper_updating_DBs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="OSM_wrapper_updating_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_ROE_extract_VLs_start_datetime_difference(self):
    """
    Getter method for ROE_extract_VLs_start_datetime_difference, mapped from YANG variable /so_log/ROE_extract_VLs_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__ROE_extract_VLs_start_datetime_difference
      
  def _set_ROE_extract_VLs_start_datetime_difference(self, v, load=False):
    """
    Setter method for ROE_extract_VLs_start_datetime_difference, mapped from YANG variable /so_log/ROE_extract_VLs_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ROE_extract_VLs_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ROE_extract_VLs_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_extract_VLs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ROE_extract_VLs_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_extract_VLs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__ROE_extract_VLs_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ROE_extract_VLs_start_datetime_difference(self):
    self.__ROE_extract_VLs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_extract_VLs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_ROE_created_VLs_start_datetime_difference(self):
    """
    Getter method for ROE_created_VLs_start_datetime_difference, mapped from YANG variable /so_log/ROE_created_VLs_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__ROE_created_VLs_start_datetime_difference
      
  def _set_ROE_created_VLs_start_datetime_difference(self, v, load=False):
    """
    Setter method for ROE_created_VLs_start_datetime_difference, mapped from YANG variable /so_log/ROE_created_VLs_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ROE_created_VLs_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ROE_created_VLs_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_created_VLs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ROE_created_VLs_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_created_VLs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__ROE_created_VLs_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ROE_created_VLs_start_datetime_difference(self):
    self.__ROE_created_VLs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_created_VLs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_ROE_updating_DBs_start_datetime_difference(self):
    """
    Getter method for ROE_updating_DBs_start_datetime_difference, mapped from YANG variable /so_log/ROE_updating_DBs_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__ROE_updating_DBs_start_datetime_difference
      
  def _set_ROE_updating_DBs_start_datetime_difference(self, v, load=False):
    """
    Setter method for ROE_updating_DBs_start_datetime_difference, mapped from YANG variable /so_log/ROE_updating_DBs_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ROE_updating_DBs_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ROE_updating_DBs_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_updating_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ROE_updating_DBs_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_updating_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__ROE_updating_DBs_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ROE_updating_DBs_start_datetime_difference(self):
    self.__ROE_updating_DBs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_updating_DBs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_create_monitoring_jobs_start_datetime_difference(self):
    """
    Getter method for create_monitoring_jobs_start_datetime_difference, mapped from YANG variable /so_log/create_monitoring_jobs_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__create_monitoring_jobs_start_datetime_difference
      
  def _set_create_monitoring_jobs_start_datetime_difference(self, v, load=False):
    """
    Setter method for create_monitoring_jobs_start_datetime_difference, mapped from YANG variable /so_log/create_monitoring_jobs_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_monitoring_jobs_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_monitoring_jobs_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_monitoring_jobs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_monitoring_jobs_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_monitoring_jobs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__create_monitoring_jobs_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_monitoring_jobs_start_datetime_difference(self):
    self.__create_monitoring_jobs_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_monitoring_jobs_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_create_threshold_based_alerts_start_datetime_difference(self):
    """
    Getter method for create_threshold_based_alerts_start_datetime_difference, mapped from YANG variable /so_log/create_threshold_based_alerts_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__create_threshold_based_alerts_start_datetime_difference
      
  def _set_create_threshold_based_alerts_start_datetime_difference(self, v, load=False):
    """
    Setter method for create_threshold_based_alerts_start_datetime_difference, mapped from YANG variable /so_log/create_threshold_based_alerts_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_threshold_based_alerts_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_threshold_based_alerts_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_threshold_based_alerts_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_threshold_based_alerts_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_threshold_based_alerts_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__create_threshold_based_alerts_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_threshold_based_alerts_start_datetime_difference(self):
    self.__create_threshold_based_alerts_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_threshold_based_alerts_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_create_AIML_alerts_start_datetime_difference(self):
    """
    Getter method for create_AIML_alerts_start_datetime_difference, mapped from YANG variable /so_log/create_AIML_alerts_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__create_AIML_alerts_start_datetime_difference
      
  def _set_create_AIML_alerts_start_datetime_difference(self, v, load=False):
    """
    Setter method for create_AIML_alerts_start_datetime_difference, mapped from YANG variable /so_log/create_AIML_alerts_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_AIML_alerts_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_AIML_alerts_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_AIML_alerts_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_AIML_alerts_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_AIML_alerts_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__create_AIML_alerts_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_AIML_alerts_start_datetime_difference(self):
    self.__create_AIML_alerts_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="create_AIML_alerts_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_wrapper_time_start_datetime_difference(self):
    """
    Getter method for wrapper_time_start_datetime_difference, mapped from YANG variable /so_log/wrapper_time_start_datetime_difference (int64)

    YANG Description: ...
    """
    return self.__wrapper_time_start_datetime_difference
      
  def _set_wrapper_time_start_datetime_difference(self, v, load=False):
    """
    Setter method for wrapper_time_start_datetime_difference, mapped from YANG variable /so_log/wrapper_time_start_datetime_difference (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wrapper_time_start_datetime_difference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wrapper_time_start_datetime_difference() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="wrapper_time_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wrapper_time_start_datetime_difference must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="wrapper_time_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__wrapper_time_start_datetime_difference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wrapper_time_start_datetime_difference(self):
    self.__wrapper_time_start_datetime_difference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="wrapper_time_start_datetime_difference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_SOA_time(self):
    """
    Getter method for SOA_time, mapped from YANG variable /so_log/SOA_time (int64)

    YANG Description: ...
    """
    return self.__SOA_time
      
  def _set_SOA_time(self, v, load=False):
    """
    Setter method for SOA_time, mapped from YANG variable /so_log/SOA_time (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_SOA_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_SOA_time() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="SOA_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """SOA_time must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="SOA_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__SOA_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_SOA_time(self):
    self.__SOA_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="SOA_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)


  def _get_ROE_time(self):
    """
    Getter method for ROE_time, mapped from YANG variable /so_log/ROE_time (int64)

    YANG Description: ...
    """
    return self.__ROE_time
      
  def _set_ROE_time(self, v, load=False):
    """
    Setter method for ROE_time, mapped from YANG variable /so_log/ROE_time (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ROE_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ROE_time() directly.

    YANG Description: ...
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ROE_time must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)""",
        })

    self.__ROE_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ROE_time(self):
    self.__ROE_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="ROE_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='int64', is_config=False)

  current_time = __builtin__.property(_get_current_time)
  nsID = __builtin__.property(_get_nsID)
  nsdID = __builtin__.property(_get_nsdID)
  total_instantiation_time = __builtin__.property(_get_total_instantiation_time)
  operation_ID_for_instantiation_op_datetime_difference = __builtin__.property(_get_operation_ID_for_instantiation_op_datetime_difference)
  hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference = __builtin__.property(_get_hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference)
  retrieving_descriptor_from_catalogue_DBs_start_datetime_difference = __builtin__.property(_get_retrieving_descriptor_from_catalogue_DBs_start_datetime_difference)
  ROE_parsing_NSDs_start_datetime_difference = __builtin__.property(_get_ROE_parsing_NSDs_start_datetime_difference)
  ROE_retrieve_RL_resources_start_datetime_difference = __builtin__.property(_get_ROE_retrieve_RL_resources_start_datetime_difference)
  PA_calculation_start_datetime_difference = __builtin__.property(_get_PA_calculation_start_datetime_difference)
  creating_networks_at_OSM_wrapper_start_datetime_difference = __builtin__.property(_get_creating_networks_at_OSM_wrapper_start_datetime_difference)
  creating_VNFs_at_OSM_wrapper_start_datetime_difference = __builtin__.property(_get_creating_VNFs_at_OSM_wrapper_start_datetime_difference)
  OSM_wrapper_updating_DBs_start_datetime_difference = __builtin__.property(_get_OSM_wrapper_updating_DBs_start_datetime_difference)
  ROE_extract_VLs_start_datetime_difference = __builtin__.property(_get_ROE_extract_VLs_start_datetime_difference)
  ROE_created_VLs_start_datetime_difference = __builtin__.property(_get_ROE_created_VLs_start_datetime_difference)
  ROE_updating_DBs_start_datetime_difference = __builtin__.property(_get_ROE_updating_DBs_start_datetime_difference)
  create_monitoring_jobs_start_datetime_difference = __builtin__.property(_get_create_monitoring_jobs_start_datetime_difference)
  create_threshold_based_alerts_start_datetime_difference = __builtin__.property(_get_create_threshold_based_alerts_start_datetime_difference)
  create_AIML_alerts_start_datetime_difference = __builtin__.property(_get_create_AIML_alerts_start_datetime_difference)
  wrapper_time_start_datetime_difference = __builtin__.property(_get_wrapper_time_start_datetime_difference)
  SOA_time = __builtin__.property(_get_SOA_time)
  ROE_time = __builtin__.property(_get_ROE_time)


  _pyangbind_elements = OrderedDict([('current_time', current_time), ('nsID', nsID), ('nsdID', nsdID), ('total_instantiation_time', total_instantiation_time), ('operation_ID_for_instantiation_op_datetime_difference', operation_ID_for_instantiation_op_datetime_difference), ('hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference', hierarchical_SOE_dispatching_SOEpSOEc_datetime_difference), ('retrieving_descriptor_from_catalogue_DBs_start_datetime_difference', retrieving_descriptor_from_catalogue_DBs_start_datetime_difference), ('ROE_parsing_NSDs_start_datetime_difference', ROE_parsing_NSDs_start_datetime_difference), ('ROE_retrieve_RL_resources_start_datetime_difference', ROE_retrieve_RL_resources_start_datetime_difference), ('PA_calculation_start_datetime_difference', PA_calculation_start_datetime_difference), ('creating_networks_at_OSM_wrapper_start_datetime_difference', creating_networks_at_OSM_wrapper_start_datetime_difference), ('creating_VNFs_at_OSM_wrapper_start_datetime_difference', creating_VNFs_at_OSM_wrapper_start_datetime_difference), ('OSM_wrapper_updating_DBs_start_datetime_difference', OSM_wrapper_updating_DBs_start_datetime_difference), ('ROE_extract_VLs_start_datetime_difference', ROE_extract_VLs_start_datetime_difference), ('ROE_created_VLs_start_datetime_difference', ROE_created_VLs_start_datetime_difference), ('ROE_updating_DBs_start_datetime_difference', ROE_updating_DBs_start_datetime_difference), ('create_monitoring_jobs_start_datetime_difference', create_monitoring_jobs_start_datetime_difference), ('create_threshold_based_alerts_start_datetime_difference', create_threshold_based_alerts_start_datetime_difference), ('create_AIML_alerts_start_datetime_difference', create_AIML_alerts_start_datetime_difference), ('wrapper_time_start_datetime_difference', wrapper_time_start_datetime_difference), ('SOA_time', SOA_time), ('ROE_time', ROE_time), ])


class logparser(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module logparser - based on the path /logparser. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: YANG module to represent 5Growth Service Orchestrator log parser.
  """
  __slots__ = ('_path_helper', '_extmethods', '__so_log',)

  _yang_name = 'logparser'
  _yang_namespace = 'http://data-aggregator.com/ns/so-log-parser'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    self._extmethods = False
    self.__so_log = YANGDynClass(base=yc_so_log_logparser__so_log, is_container='container', yang_name="so-log", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_so_log(self):
    """
    Getter method for so_log, mapped from YANG variable /so_log (container)

    YANG Description: Enclosing container for the record
of a given log.
    """
    return self.__so_log
      
  def _set_so_log(self, v, load=False):
    """
    Setter method for so_log, mapped from YANG variable /so_log (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_so_log is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_so_log() directly.

    YANG Description: Enclosing container for the record
of a given log.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_so_log_logparser__so_log, is_container='container', yang_name="so-log", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """so_log must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_so_log_logparser__so_log, is_container='container', yang_name="so-log", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='container', is_config=True)""",
        })

    self.__so_log = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_so_log(self):
    self.__so_log = YANGDynClass(base=yc_so_log_logparser__so_log, is_container='container', yang_name="so-log", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://data-aggregator.com/ns/so-log-parser', defining_module='logparser', yang_type='container', is_config=True)

  so_log = __builtin__.property(_get_so_log, _set_so_log)


  _pyangbind_elements = OrderedDict([('so_log', so_log), ])


